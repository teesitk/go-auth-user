
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>grpc: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">go-auth-user/adapter/grpc/user_grpc.go (77.8%)</option>
				
				<option value="file1">go-auth-user/adapter/http/auth_handler.go (37.9%)</option>
				
				<option value="file2">go-auth-user/adapter/http/auth_middleware.go (0.0%)</option>
				
				<option value="file3">go-auth-user/adapter/http/logger_middleware.go (0.0%)</option>
				
				<option value="file4">go-auth-user/adapter/http/user_handler.go (0.0%)</option>
				
				<option value="file5">go-auth-user/adapter/mongo/user_repository.go (0.0%)</option>
				
				<option value="file6">go-auth-user/main.go (0.0%)</option>
				
				<option value="file7">go-auth-user/proto/user.pb.go (0.0%)</option>
				
				<option value="file8">go-auth-user/proto/user_grpc.pb.go (0.0%)</option>
				
				<option value="file9">go-auth-user/service/auth.go (57.1%)</option>
				
				<option value="file10">go-auth-user/service/user.go (0.0%)</option>
				
				<option value="file11">go-auth-user/tests/mocks/mock_auth_repo.go (0.0%)</option>
				
				<option value="file12">go-auth-user/tests/mocks/mock_user_repo.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package grpcadapter

import (
        "context"
        "errors"
        "net/http"

        "go-auth-user/domain"
        pb "go-auth-user/proto"
)

type UserServiceServer struct {
        pb.UnimplementedUserServiceServer
        UserRepo domain.UserRepository
}

func NewUserServiceServer(repo domain.UserRepository) *UserServiceServer <span class="cov8" title="1">{
        return &amp;UserServiceServer{
                UserRepo: repo,
        }
}</span>

func (s *UserServiceServer) CreateUser(ctx context.Context, req *pb.CreateUserRequest) (*pb.CreateUserResponse, error) <span class="cov8" title="1">{
        user := &amp;domain.User{
                Name:     req.Name,
                Email:    req.Email,
                Password: req.Password, // In real-world: hash this!
        }

        if err := s.UserRepo.Create(user); err != nil </span><span class="cov0" title="0">{
                return &amp;pb.CreateUserResponse{}, err
        }</span>

        <span class="cov8" title="1">return &amp;pb.CreateUserResponse{Code: http.StatusCreated, Message: "success"}, nil</span>
}

func (s *UserServiceServer) GetUser(ctx context.Context, req *pb.GetUserRequest) (*pb.GetUserResponse, error) <span class="cov8" title="1">{
        user := s.UserRepo.FindByEmail(req.Email)
        if user == nil </span><span class="cov0" title="0">{
                return nil, errors.New("user not found")
        }</span>

        <span class="cov8" title="1">return &amp;pb.GetUserResponse{
                Id:    "1",
                Name:  user.Name,
                Email: user.Email,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package http

import (
        "encoding/json"
        "go-auth-user/domain"
        "net/http"

        "github.com/go-playground/validator/v10"
)

type AuthHandler struct {
        Service domain.AuthService
}

type stdAuthResp struct {
        Code    int
        Message string
}

type errAuthResp struct {
        Code  int
        Error string
}
type authResp struct {
        stdAuthResp
        Token string
}

func NewAuthHandler(service domain.AuthService) *AuthHandler <span class="cov8" title="1">{
        return &amp;AuthHandler{Service: service}
}</span>

func (h *AuthHandler) Authenticate(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req struct {
                User     string
                Password string
        }
        var res authResp
        res.Code = http.StatusOK
        res.Message = "success"
        json.NewDecoder(r.Body).Decode(&amp;req)
        auth, err := h.Service.Authenticate(req.User, req.Password)
        res.Token = auth.Token
        if err != nil </span><span class="cov0" title="0">{
                erJson, _ := json.MarshalIndent(&amp;errResp{Code: http.StatusUnauthorized, Error: err.Error()}, "", "    ")
                http.Error(w, string(erJson), http.StatusUnauthorized)
                return
        }</span>
        <span class="cov0" title="0">json.NewEncoder(w).Encode(res)</span>
}

func (h *AuthHandler) Signup(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{

        validate := validator.New(validator.WithRequiredStructEnabled())
        var req struct {
                Name     string `validate:"required"`
                Email    string `validate:"required,email"`
                Password string `validate:"required"`
        }
        var res stdAuthResp
        res.Code = http.StatusOK
        res.Message = "success"
        json.NewDecoder(r.Body).Decode(&amp;req)
        if err := validate.Struct(req); err != nil </span><span class="cov0" title="0">{
                erJson, _ := json.MarshalIndent(&amp;errAuthResp{Code: http.StatusBadRequest, Error: err.Error()}, "", "    ")
                http.Error(w, string(erJson), http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">err := h.Service.Signup(req.Name, req.Email, req.Password)
        if err != nil </span><span class="cov0" title="0">{
                erJson, _ := json.MarshalIndent(&amp;errAuthResp{Code: http.StatusBadRequest, Error: err.Error()}, "", "    ")
                http.Error(w, string(erJson), http.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">json.NewEncoder(w).Encode(res)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package http

import (
        "context"
        "encoding/json"
        "go-auth-user/domain"
        "net/http"
        "strings"
)

type key string

const userContextKey key = "user"

func JWTMiddleware(authService domain.AuthService, next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                authHeader := r.Header.Get("Authorization")
                if authHeader == "" || !strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov0" title="0">{
                        erJson, _ := json.MarshalIndent(errAuthResp{Code: http.StatusUnauthorized, Error: "Missing or invalid Authorization header"}, "", "    ")
                        http.Error(w, string(erJson), http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov0" title="0">token := strings.TrimPrefix(authHeader, "Bearer ")
                user, err := authService.ParseToken(token)
                if err != nil </span><span class="cov0" title="0">{
                        erJson, _ := json.MarshalIndent(errAuthResp{Code: http.StatusUnauthorized, Error: "Invalid token"}, "", "    ")
                        http.Error(w, string(erJson), http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov0" title="0">ctx := context.WithValue(r.Context(), userContextKey, user)
                next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}

func GetUserFromContext(ctx context.Context) *domain.User <span class="cov0" title="0">{
        user, ok := ctx.Value(userContextKey).(*domain.User)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return user</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package http

import (
        "log"
        "net/http"
        "time"
)

type responseWriter struct {
        http.ResponseWriter
        statusCode int
}

func (rw *responseWriter) WriteHeader(code int) <span class="cov0" title="0">{
        rw.statusCode = code
        rw.ResponseWriter.WriteHeader(code)
}</span>

func LoggingMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                start := time.Now()

                rw := &amp;responseWriter{ResponseWriter: w, statusCode: http.StatusOK}
                next.ServeHTTP(rw, r)

                duration := time.Since(start)
                log.Printf("[%d] %s %s (%s)", rw.statusCode, r.Method, r.URL.Path, duration)
        }</span>)
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package http

import (
        "encoding/json"
        "go-auth-user/domain"
        "net/http"

        "github.com/go-playground/validator/v10"
)

type UserHandler struct {
        Service domain.UserService
}

type stdResp struct {
        Code    int
        Message string
}

type errResp struct {
        Code  int
        Error string
}

type listResp struct {
        stdResp
        Data []domain.User
}

type getResp struct {
        stdResp
        Data *domain.User
}

func NewUserHandler(service domain.UserService) *UserHandler <span class="cov0" title="0">{
        return &amp;UserHandler{Service: service}
}</span>

func (h *UserHandler) CreateUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        validate := validator.New(validator.WithRequiredStructEnabled())
        var req struct {
                Name     string `validate:"required"`
                Email    string `validate:"required,email"`
                Password string `validate:"required"`
        }
        var res getResp
        res.Code = http.StatusOK
        res.Message = "success"
        json.NewDecoder(r.Body).Decode(&amp;req)
        if err := validate.Struct(req); err != nil </span><span class="cov0" title="0">{
                erJson, _ := json.MarshalIndent(&amp;errResp{Code: http.StatusBadRequest, Error: err.Error()}, "", "    ")
                http.Error(w, string(erJson), http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">user, err := h.Service.CreateUser(req.Name, req.Email, req.Password)
        res.Data = user
        if err != nil </span><span class="cov0" title="0">{
                erJson, _ := json.MarshalIndent(&amp;errResp{Code: http.StatusBadRequest, Error: err.Error()}, "", "    ")
                http.Error(w, string(erJson), http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">json.NewEncoder(w).Encode(res)</span>
}

func (h *UserHandler) GetUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req struct{ Id int }
        var res getResp
        res.Code = http.StatusOK
        res.Message = "success"
        json.NewDecoder(r.Body).Decode(&amp;req)
        user := h.Service.GetUser(req.Id)
        res.Data = user
        if user == nil </span><span class="cov0" title="0">{
                erJson, _ := json.MarshalIndent(&amp;errResp{Code: http.StatusNotFound, Error: "user not found"}, "", "    ")
                http.Error(w, string(erJson), http.StatusNotFound)
                return
        }</span>
        <span class="cov0" title="0">json.NewEncoder(w).Encode(res)</span>
}

func (h *UserHandler) ListUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req struct {
                Page    int
                PerPage int
        }
        var res listResp
        res.Code = http.StatusOK
        res.Message = "success"

        json.NewDecoder(r.Body).Decode(&amp;req)
        users := h.Service.ListUser(req.Page, req.PerPage)
        res.Data = users
        json.NewEncoder(w).Encode(res)
}</span>

func (h *UserHandler) UpdateUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req struct {
                Id    int
                Name  string
                Email string
        }
        json.NewDecoder(r.Body).Decode(&amp;req)
        var res stdResp
        res.Code = http.StatusOK
        res.Message = "success"

        err := h.Service.UpdateUser(req.Id, req.Name, req.Email)
        if err != nil </span><span class="cov0" title="0">{
                erJson, _ := json.MarshalIndent(&amp;errResp{Code: http.StatusBadRequest, Error: err.Error()}, "", "    ")
                http.Error(w, string(erJson), http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">json.NewEncoder(w).Encode(res)</span>
}

func (h *UserHandler) DeleteUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req struct {
                Id int
        }
        json.NewDecoder(r.Body).Decode(&amp;req)
        var res stdResp
        res.Code = http.StatusOK
        res.Message = "success"

        err := h.Service.DeleteUser(req.Id)
        if err != nil </span><span class="cov0" title="0">{
                erJson, _ := json.MarshalIndent(&amp;errResp{Code: http.StatusBadRequest, Error: err.Error()}, "", "    ")
                http.Error(w, string(erJson), http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">json.NewEncoder(w).Encode(res)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package mongo

import (
        "context"
        "fmt"
        "go-auth-user/domain"
        "log"
        "time"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

type UserRepo struct {
        collection *mongo.Collection
}

func NewUserRepo(client *mongo.Client, dbName, collectionName string) *UserRepo <span class="cov0" title="0">{
        coll := client.Database(dbName).Collection(collectionName)
        if err := ensureUserEmailIndex(coll); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create index: %v", err)
        }</span>
        <span class="cov0" title="0">return &amp;UserRepo{collection: coll}</span>
}

func (r *UserRepo) Create(user *domain.User) error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        _, err := r.collection.InsertOne(ctx, bson.M{
                "id":       user.Id,
                "name":     user.Name,
                "email":    user.Email,
                "password": user.Password,
        })
        if mongo.IsDuplicateKeyError(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("user with email %s already exists", user.Email)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">seq, err := getNextSequenceValue(ctx, r.collection.Database(), "users")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">user.Id = int(seq)
        _, err = r.collection.UpdateOne(ctx, bson.M{"email": user.Email}, bson.M{"$set": bson.M{"id": user.Id}})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *UserRepo) Find(id int) *domain.User <span class="cov0" title="0">{
        var user struct {
                Id    int    `bson:"id"`
                Name  string `bson:"name"`
                Email string `bson:"email"`
        }

        err := r.collection.FindOne(context.Background(), bson.M{"id": id}).Decode(&amp;user)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;domain.User{
                Id:    int(user.Id),
                Name:  user.Name,
                Email: user.Email,
        }</span>
}

func (r *UserRepo) FindByEmail(email string) *domain.User <span class="cov0" title="0">{
        var user struct {
                Id       int    `bson:"id"`
                Name     string `bson:"name"`
                Email    string `bson:"email"`
                Password string `bson:"password"`
        }

        err := r.collection.FindOne(context.Background(), bson.M{"email": email}).Decode(&amp;user)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;domain.User{
                Id:       int(user.Id),
                Name:     user.Name,
                Email:    user.Email,
                Password: user.Password,
        }</span>
}

func (r *UserRepo) FindAll(page int, perPage int) []domain.User <span class="cov0" title="0">{
        ctx := context.Background()

        opts := options.Find().
                SetSkip((int64(page) - 1) * int64(perPage)).
                SetLimit(int64(perPage)).
                SetSort(bson.D{{Key: "_id", Value: 1}}).
                SetProjection(bson.M{
                        "password": 0,
                })

        cursor, err := r.collection.Find(ctx, bson.M{}, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var users []domain.User
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var user domain.User
                if err := cursor.Decode(&amp;user); err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">users = append(users, user)</span>
        }

        <span class="cov0" title="0">if err := cursor.Err(); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return users</span>
}

func (r *UserRepo) Update(id int, name string, email string) (result *mongo.UpdateResult, err error) <span class="cov0" title="0">{
        ctx := context.Background()

        updateData := bson.M{}
        if name != "" </span><span class="cov0" title="0">{
                updateData["name"] = name
        }</span>
        <span class="cov0" title="0">if email != "" </span><span class="cov0" title="0">{
                updateData["email"] = email
        }</span>
        <span class="cov0" title="0">result, err = r.collection.UpdateOne(ctx, bson.M{"id": id}, bson.M{"$set": updateData})
        if mongo.IsDuplicateKeyError(err) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user with email %s already exists", email)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

func (r *UserRepo) Delete(id int) error <span class="cov0" title="0">{
        ctx := context.Background()
        _, err := r.collection.DeleteOne(ctx, bson.M{"id": id})
        return err
}</span>

func (r *UserRepo) CountUsers() (int64, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        return r.collection.CountDocuments(ctx, bson.M{})
}</span>

func getNextSequenceValue(ctx context.Context, db *mongo.Database, sequenceName string) (int32, error) <span class="cov0" title="0">{
        filter := bson.M{"_id": sequenceName}
        update := bson.M{"$inc": bson.M{"seq": 1}}

        opts := options.FindOneAndUpdate().SetUpsert(true).SetReturnDocument(options.After)

        var updatedDoc bson.M
        err := db.Collection("counters").FindOneAndUpdate(ctx, filter, update, opts).Decode(&amp;updatedDoc)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return updatedDoc["seq"].(int32), nil</span>
}

func ensureUserEmailIndex(collection *mongo.Collection) error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        index := mongo.IndexModel{
                Keys:    bson.D{{Key: "email", Value: 1}},
                Options: options.Index().SetUnique(true),
        }

        _, err := collection.Indexes().CreateOne(ctx, index)
        return err
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "context"
        "fmt"
        grpcAdapter "go-auth-user/adapter/grpc"
        httpAdapter "go-auth-user/adapter/http"
        mongoAdapter "go-auth-user/adapter/mongo"
        pb "go-auth-user/proto"
        "go-auth-user/service"
        "log"
        "net"
        "net/http"
        "time"

        "github.com/gorilla/mux"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
        "google.golang.org/grpc"
)

func main() <span class="cov0" title="0">{
        //JWT
        jwtSecret := "secret"
        // connect mongoDB
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        username := "user"
        password := "pass"
        host := "localhost"
        port := "27017"
        dbName := "go-auth-user"

        uri := fmt.Sprintf("mongodb://%s:%s@%s:%s/%s?authSource=admin", username, password, host, port, dbName)
        client, err := mongo.Connect(ctx, options.Client().ApplyURI(uri))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("MongoDB connection error: %v", err)
        }</span>

        <span class="cov0" title="0">userRepo := mongoAdapter.NewUserRepo(client, "go-auth-user", "users")
        userService := service.NewUserService(userRepo)
        userHandler := httpAdapter.NewUserHandler(userService)
        authService := service.NewAuthService(userRepo, jwtSecret)
        authHandler := httpAdapter.NewAuthHandler(authService)

        // Mux Router
        r := mux.NewRouter()
        r.Use(httpAdapter.LoggingMiddleware)

        r.HandleFunc("/authenticate", authHandler.Authenticate).Methods("POST")
        r.HandleFunc("/signup", authHandler.Signup).Methods("POST")

        // Protected routes
        api := r.PathPrefix("/api").Subrouter()
        api.Use(func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return httpAdapter.JWTMiddleware(authService, next)
        }</span>)
        <span class="cov0" title="0">api.HandleFunc("/users", userHandler.ListUser)
        api.HandleFunc("/user", userHandler.GetUser)
        api.HandleFunc("/users/create", userHandler.CreateUser).Methods("POST")
        api.HandleFunc("/users/update", userHandler.UpdateUser).Methods("PUT")
        api.HandleFunc("/users/delete", userHandler.DeleteUser).Methods("DELETE")

        //Logging users counter in mongoDB
        go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(10 * time.Second)
                defer ticker.Stop()

                for </span><span class="cov0" title="0">{
                        &lt;-ticker.C
                        count, err := userRepo.CountUsers()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("[ERROR] Counting users: %v", err)
                                continue</span>
                        }
                        <span class="cov0" title="0">log.Printf("[INFO] Total users in DB: %d", count)</span>
                }
        }()

        //Provide sum grpc server
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                lis, err := net.Listen("tcp", ":9000")
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("failed to listen: %v", err)
                }</span>

                <span class="cov0" title="0">grpcServer := grpc.NewServer()
                userService := grpcAdapter.NewUserServiceServer(userRepo)
                pb.RegisterUserServiceServer(grpcServer, userService)

                log.Println("gRPC server listening on :9000")
                if err := grpcServer.Serve(lis); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("failed to serve: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">log.Println("server running on http://localhost:8080")
        http.ListenAndServe(":8080", r)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.6
//         protoc        v6.30.2
// source: proto/user.proto

package proto

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type CreateUserRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        Email         string                 `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty"`
        Password      string                 `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CreateUserRequest) Reset() <span class="cov0" title="0">{
        *x = CreateUserRequest{}
        mi := &amp;file_proto_user_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreateUserRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateUserRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateUserRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_user_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateUserRequest.ProtoReflect.Descriptor instead.
func (*CreateUserRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_user_proto_rawDescGZIP(), []int{0}
}</span>

func (x *CreateUserRequest) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateUserRequest) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateUserRequest) GetPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CreateUserResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Code          int32                  `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
        Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CreateUserResponse) Reset() <span class="cov0" title="0">{
        *x = CreateUserResponse{}
        mi := &amp;file_proto_user_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreateUserResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateUserResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateUserResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_user_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateUserResponse.ProtoReflect.Descriptor instead.
func (*CreateUserResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_user_proto_rawDescGZIP(), []int{1}
}</span>

func (x *CreateUserResponse) GetCode() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Code
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *CreateUserResponse) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetUserRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Email         string                 `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetUserRequest) Reset() <span class="cov0" title="0">{
        *x = GetUserRequest{}
        mi := &amp;file_proto_user_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetUserRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetUserRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetUserRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_user_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetUserRequest.ProtoReflect.Descriptor instead.
func (*GetUserRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_user_proto_rawDescGZIP(), []int{2}
}</span>

func (x *GetUserRequest) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetUserResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Name          string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
        Email         string                 `protobuf:"bytes,3,opt,name=email,proto3" json:"email,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetUserResponse) Reset() <span class="cov0" title="0">{
        *x = GetUserResponse{}
        mi := &amp;file_proto_user_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetUserResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetUserResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetUserResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_user_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetUserResponse.ProtoReflect.Descriptor instead.
func (*GetUserResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_user_proto_rawDescGZIP(), []int{3}
}</span>

func (x *GetUserResponse) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetUserResponse) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetUserResponse) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_proto_user_proto protoreflect.FileDescriptor

const file_proto_user_proto_rawDesc = "" +
        "\n" +
        "\x10proto/user.proto\x12\x04user\"Y\n" +
        "\x11CreateUserRequest\x12\x12\n" +
        "\x04name\x18\x01 \x01(\tR\x04name\x12\x14\n" +
        "\x05email\x18\x02 \x01(\tR\x05email\x12\x1a\n" +
        "\bpassword\x18\x03 \x01(\tR\bpassword\"B\n" +
        "\x12CreateUserResponse\x12\x12\n" +
        "\x04code\x18\x01 \x01(\x05R\x04code\x12\x18\n" +
        "\amessage\x18\x02 \x01(\tR\amessage\"&amp;\n" +
        "\x0eGetUserRequest\x12\x14\n" +
        "\x05email\x18\x01 \x01(\tR\x05email\"K\n" +
        "\x0fGetUserResponse\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
        "\x04name\x18\x02 \x01(\tR\x04name\x12\x14\n" +
        "\x05email\x18\x03 \x01(\tR\x05email2\x86\x01\n" +
        "\vUserService\x12?\n" +
        "\n" +
        "CreateUser\x12\x17.user.CreateUserRequest\x1a\x18.user.CreateUserResponse\x126\n" +
        "\aGetUser\x12\x14.user.GetUserRequest\x1a\x15.user.GetUserResponseB\tZ\a./protob\x06proto3"

var (
        file_proto_user_proto_rawDescOnce sync.Once
        file_proto_user_proto_rawDescData []byte
)

func file_proto_user_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_proto_user_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_proto_user_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_proto_user_proto_rawDesc), len(file_proto_user_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_proto_user_proto_rawDescData</span>
}

var file_proto_user_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_proto_user_proto_goTypes = []any{
        (*CreateUserRequest)(nil),  // 0: user.CreateUserRequest
        (*CreateUserResponse)(nil), // 1: user.CreateUserResponse
        (*GetUserRequest)(nil),     // 2: user.GetUserRequest
        (*GetUserResponse)(nil),    // 3: user.GetUserResponse
}
var file_proto_user_proto_depIdxs = []int32{
        0, // 0: user.UserService.CreateUser:input_type -&gt; user.CreateUserRequest
        2, // 1: user.UserService.GetUser:input_type -&gt; user.GetUserRequest
        1, // 2: user.UserService.CreateUser:output_type -&gt; user.CreateUserResponse
        3, // 3: user.UserService.GetUser:output_type -&gt; user.GetUserResponse
        2, // [2:4] is the sub-list for method output_type
        0, // [0:2] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_proto_user_proto_init() }</span>
func file_proto_user_proto_init() <span class="cov0" title="0">{
        if File_proto_user_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_proto_user_proto_rawDesc), len(file_proto_user_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   4,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_proto_user_proto_goTypes,
                DependencyIndexes: file_proto_user_proto_depIdxs,
                MessageInfos:      file_proto_user_proto_msgTypes,
        }.Build()
        File_proto_user_proto = out.File
        file_proto_user_proto_goTypes = nil
        file_proto_user_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.30.2
// source: proto/user.proto

package proto

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        UserService_CreateUser_FullMethodName = "/user.UserService/CreateUser"
        UserService_GetUser_FullMethodName    = "/user.UserService/GetUser"
)

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserServiceClient interface {
        CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserResponse, error)
        GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*GetUserResponse, error)
}

type userServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient <span class="cov0" title="0">{
        return &amp;userServiceClient{cc}
}</span>

func (c *userServiceClient) CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(CreateUserResponse)
        err := c.cc.Invoke(ctx, UserService_CreateUser_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *userServiceClient) GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*GetUserResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetUserResponse)
        err := c.cc.Invoke(ctx, UserService_GetUser_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility.
type UserServiceServer interface {
        CreateUser(context.Context, *CreateUserRequest) (*CreateUserResponse, error)
        GetUser(context.Context, *GetUserRequest) (*GetUserResponse, error)
        mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserServiceServer struct{}

func (UnimplementedUserServiceServer) CreateUser(context.Context, *CreateUserRequest) (*CreateUserResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}</span>
func (UnimplementedUserServiceServer) GetUser(context.Context, *GetUserRequest) (*GetUserResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}</span>
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {<span class="cov0" title="0">}</span>
func (UnimplementedUserServiceServer) testEmbeddedByValue()                     {<span class="cov0" title="0">}</span>

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
        mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedUserServiceServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;UserService_ServiceDesc, srv)</span>
}

func _UserService_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CreateUserRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).CreateUser(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: UserService_CreateUser_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).CreateUser(ctx, req.(*CreateUserRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _UserService_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetUserRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).GetUser(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: UserService_GetUser_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).GetUser(ctx, req.(*GetUserRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "user.UserService",
        HandlerType: (*UserServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "CreateUser",
                        Handler:    _UserService_CreateUser_Handler,
                },
                {
                        MethodName: "GetUser",
                        Handler:    _UserService_GetUser_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "proto/user.proto",
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package service

import (
        "crypto/md5"
        "encoding/hex"
        "errors"
        "go-auth-user/domain"
        "time"

        "github.com/golang-jwt/jwt/v5"
)

type AuthServiceImpl struct {
        UserRepo  domain.UserRepository
        JWTSecret string
}

// Authenticate implements domain.AuthService.
func (a *AuthServiceImpl) Authenticate(user string, password string) (auth *domain.Auth, err error) <span class="cov8" title="1">{
        hash := md5.Sum([]byte(password))
        pass := hex.EncodeToString(hash[:])
        result := a.UserRepo.FindByEmail(user)
        if result.Email == user &amp;&amp; result.Password == pass </span><span class="cov8" title="1">{
                //create token
                token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
                        "sub":   result.Id,
                        "email": result.Email,
                        "exp":   time.Now().Add(time.Hour * 24).Unix(),
                })
                signed, err := token.SignedString([]byte(a.JWTSecret))
                return &amp;domain.Auth{Token: signed}, err
        }</span>
        <span class="cov0" title="0">return &amp;domain.Auth{}, errors.New("invalid user or password")</span>
}

func (a *AuthServiceImpl) Signup(name string, email string, password string) error <span class="cov8" title="1">{
        hash := md5.Sum([]byte(password))
        user := &amp;domain.User{
                Id:       0,
                Name:     name,
                Email:    email,
                Password: hex.EncodeToString(hash[:]),
        }
        err := a.UserRepo.Create(user)
        return err
}</span>

func (a *AuthServiceImpl) ParseToken(tokenStr string) (*domain.User, error) <span class="cov0" title="0">{
        token, err := jwt.Parse(tokenStr, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                return []byte(a.JWTSecret), nil
        }</span>)

        <span class="cov0" title="0">if claims, ok := token.Claims.(jwt.MapClaims); ok &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                email, ok := claims["email"].(string)
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.New("invalid token claims")
                }</span>
                <span class="cov0" title="0">return a.UserRepo.FindByEmail(email), nil</span>
        }

        <span class="cov0" title="0">return nil, err</span>

}

func NewAuthService(repo domain.UserRepository, secret string) domain.AuthService <span class="cov8" title="1">{
        return &amp;AuthServiceImpl{UserRepo: repo, JWTSecret: secret}
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package service

import (
        "crypto/md5"
        "encoding/hex"
        "go-auth-user/domain"
)

type UserServiceImpl struct {
        Repo domain.UserRepository
}

func NewUserService(repo domain.UserRepository) domain.UserService <span class="cov0" title="0">{
        return &amp;UserServiceImpl{Repo: repo}
}</span>

// CreateUser implements domain.UserService.
func (u *UserServiceImpl) CreateUser(name string, email string, password string) (*domain.User, error) <span class="cov0" title="0">{
        hash := md5.Sum([]byte(password))
        user := &amp;domain.User{
                Id:       0,
                Name:     name,
                Email:    email,
                Password: hex.EncodeToString(hash[:]),
        }
        err := u.Repo.Create(user)
        return user, err
}</span>

// DeleteUser implements domain.UserService.
func (u *UserServiceImpl) DeleteUser(id int) error <span class="cov0" title="0">{
        err := u.Repo.Delete(id)
        return err
}</span>

// GetUser implements domain.UserService.
func (u *UserServiceImpl) GetUser(id int) *domain.User <span class="cov0" title="0">{
        user := u.Repo.Find(id)
        return user
}</span>

// ListUser implements domain.UserService.
func (u *UserServiceImpl) ListUser(page int, perPage int) []domain.User <span class="cov0" title="0">{
        users := u.Repo.FindAll(page, perPage)
        return users
}</span>

// UpdateUser implements domain.UserService.
func (u *UserServiceImpl) UpdateUser(id int, name string, email string) error <span class="cov0" title="0">{
        _, err := u.Repo.Update(id, name, email)
        return err
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: domain/auth.go
//
// Generated by this command:
//
//        mockgen -source=domain/auth.go -destination=tests/mocks/mock_auth_repo.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
        domain "go-auth-user/domain"
        reflect "reflect"

        gomock "go.uber.org/mock/gomock"
)

// MockAuthService is a mock of AuthService interface.
type MockAuthService struct {
        ctrl     *gomock.Controller
        recorder *MockAuthServiceMockRecorder
        isgomock struct{}
}

// MockAuthServiceMockRecorder is the mock recorder for MockAuthService.
type MockAuthServiceMockRecorder struct {
        mock *MockAuthService
}

// NewMockAuthService creates a new mock instance.
func NewMockAuthService(ctrl *gomock.Controller) *MockAuthService <span class="cov0" title="0">{
        mock := &amp;MockAuthService{ctrl: ctrl}
        mock.recorder = &amp;MockAuthServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAuthService) EXPECT() *MockAuthServiceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Authenticate mocks base method.
func (m *MockAuthService) Authenticate(user, password string) (*domain.Auth, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Authenticate", user, password)
        ret0, _ := ret[0].(*domain.Auth)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Authenticate indicates an expected call of Authenticate.
func (mr *MockAuthServiceMockRecorder) Authenticate(user, password any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Authenticate", reflect.TypeOf((*MockAuthService)(nil).Authenticate), user, password)
}</span>

// ParseToken mocks base method.
func (m *MockAuthService) ParseToken(token string) (*domain.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ParseToken", token)
        ret0, _ := ret[0].(*domain.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ParseToken indicates an expected call of ParseToken.
func (mr *MockAuthServiceMockRecorder) ParseToken(token any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ParseToken", reflect.TypeOf((*MockAuthService)(nil).ParseToken), token)
}</span>

// Signup mocks base method.
func (m *MockAuthService) Signup(name, email, password string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Signup", name, email, password)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Signup indicates an expected call of Signup.
func (mr *MockAuthServiceMockRecorder) Signup(name, email, password any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Signup", reflect.TypeOf((*MockAuthService)(nil).Signup), name, email, password)
}</span>

// MockAuthRepository is a mock of AuthRepository interface.
type MockAuthRepository struct {
        ctrl     *gomock.Controller
        recorder *MockAuthRepositoryMockRecorder
        isgomock struct{}
}

// MockAuthRepositoryMockRecorder is the mock recorder for MockAuthRepository.
type MockAuthRepositoryMockRecorder struct {
        mock *MockAuthRepository
}

// NewMockAuthRepository creates a new mock instance.
func NewMockAuthRepository(ctrl *gomock.Controller) *MockAuthRepository <span class="cov0" title="0">{
        mock := &amp;MockAuthRepository{ctrl: ctrl}
        mock.recorder = &amp;MockAuthRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAuthRepository) EXPECT() *MockAuthRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: domain/user.go
//
// Generated by this command:
//
//        mockgen -source=domain/user.go -destination=tests/mocks/mock_user_repo.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
        domain "go-auth-user/domain"
        reflect "reflect"

        mongo "go.mongodb.org/mongo-driver/mongo"
        gomock "go.uber.org/mock/gomock"
)

// MockUserService is a mock of UserService interface.
type MockUserService struct {
        ctrl     *gomock.Controller
        recorder *MockUserServiceMockRecorder
        isgomock struct{}
}

// MockUserServiceMockRecorder is the mock recorder for MockUserService.
type MockUserServiceMockRecorder struct {
        mock *MockUserService
}

// NewMockUserService creates a new mock instance.
func NewMockUserService(ctrl *gomock.Controller) *MockUserService <span class="cov0" title="0">{
        mock := &amp;MockUserService{ctrl: ctrl}
        mock.recorder = &amp;MockUserServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserService) EXPECT() *MockUserServiceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CreateUser mocks base method.
func (m *MockUserService) CreateUser(name, email, password string) (*domain.User, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateUser", name, email, password)
        ret0, _ := ret[0].(*domain.User)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateUser indicates an expected call of CreateUser.
func (mr *MockUserServiceMockRecorder) CreateUser(name, email, password any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateUser", reflect.TypeOf((*MockUserService)(nil).CreateUser), name, email, password)
}</span>

// DeleteUser mocks base method.
func (m *MockUserService) DeleteUser(id int) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteUser", id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteUser indicates an expected call of DeleteUser.
func (mr *MockUserServiceMockRecorder) DeleteUser(id any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteUser", reflect.TypeOf((*MockUserService)(nil).DeleteUser), id)
}</span>

// GetUser mocks base method.
func (m *MockUserService) GetUser(id int) *domain.User <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetUser", id)
        ret0, _ := ret[0].(*domain.User)
        return ret0
}</span>

// GetUser indicates an expected call of GetUser.
func (mr *MockUserServiceMockRecorder) GetUser(id any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUser", reflect.TypeOf((*MockUserService)(nil).GetUser), id)
}</span>

// ListUser mocks base method.
func (m *MockUserService) ListUser(page, perPage int) []domain.User <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListUser", page, perPage)
        ret0, _ := ret[0].([]domain.User)
        return ret0
}</span>

// ListUser indicates an expected call of ListUser.
func (mr *MockUserServiceMockRecorder) ListUser(page, perPage any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListUser", reflect.TypeOf((*MockUserService)(nil).ListUser), page, perPage)
}</span>

// UpdateUser mocks base method.
func (m *MockUserService) UpdateUser(id int, name, email string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateUser", id, name, email)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateUser indicates an expected call of UpdateUser.
func (mr *MockUserServiceMockRecorder) UpdateUser(id, name, email any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateUser", reflect.TypeOf((*MockUserService)(nil).UpdateUser), id, name, email)
}</span>

// MockUserRepository is a mock of UserRepository interface.
type MockUserRepository struct {
        ctrl     *gomock.Controller
        recorder *MockUserRepositoryMockRecorder
        isgomock struct{}
}

// MockUserRepositoryMockRecorder is the mock recorder for MockUserRepository.
type MockUserRepositoryMockRecorder struct {
        mock *MockUserRepository
}

// NewMockUserRepository creates a new mock instance.
func NewMockUserRepository(ctrl *gomock.Controller) *MockUserRepository <span class="cov0" title="0">{
        mock := &amp;MockUserRepository{ctrl: ctrl}
        mock.recorder = &amp;MockUserRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUserRepository) EXPECT() *MockUserRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CountUsers mocks base method.
func (m *MockUserRepository) CountUsers() (int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CountUsers")
        ret0, _ := ret[0].(int64)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CountUsers indicates an expected call of CountUsers.
func (mr *MockUserRepositoryMockRecorder) CountUsers() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountUsers", reflect.TypeOf((*MockUserRepository)(nil).CountUsers))
}</span>

// Create mocks base method.
func (m *MockUserRepository) Create(user *domain.User) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", user)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Create indicates an expected call of Create.
func (mr *MockUserRepositoryMockRecorder) Create(user any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockUserRepository)(nil).Create), user)
}</span>

// Delete mocks base method.
func (m *MockUserRepository) Delete(id int) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockUserRepositoryMockRecorder) Delete(id any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockUserRepository)(nil).Delete), id)
}</span>

// Find mocks base method.
func (m *MockUserRepository) Find(id int) *domain.User <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Find", id)
        ret0, _ := ret[0].(*domain.User)
        return ret0
}</span>

// Find indicates an expected call of Find.
func (mr *MockUserRepositoryMockRecorder) Find(id any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Find", reflect.TypeOf((*MockUserRepository)(nil).Find), id)
}</span>

// FindAll mocks base method.
func (m *MockUserRepository) FindAll(page, perPage int) []domain.User <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindAll", page, perPage)
        ret0, _ := ret[0].([]domain.User)
        return ret0
}</span>

// FindAll indicates an expected call of FindAll.
func (mr *MockUserRepositoryMockRecorder) FindAll(page, perPage any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindAll", reflect.TypeOf((*MockUserRepository)(nil).FindAll), page, perPage)
}</span>

// FindByEmail mocks base method.
func (m *MockUserRepository) FindByEmail(email string) *domain.User <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindByEmail", email)
        ret0, _ := ret[0].(*domain.User)
        return ret0
}</span>

// FindByEmail indicates an expected call of FindByEmail.
func (mr *MockUserRepositoryMockRecorder) FindByEmail(email any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByEmail", reflect.TypeOf((*MockUserRepository)(nil).FindByEmail), email)
}</span>

// Update mocks base method.
func (m *MockUserRepository) Update(id int, name, email string) (*mongo.UpdateResult, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", id, name, email)
        ret0, _ := ret[0].(*mongo.UpdateResult)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Update indicates an expected call of Update.
func (mr *MockUserRepositoryMockRecorder) Update(id, name, email any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockUserRepository)(nil).Update), id, name, email)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
